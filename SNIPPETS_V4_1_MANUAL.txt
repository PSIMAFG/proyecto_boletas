# ================================================================
# SNIPPET 1: Agregar a BatchMemory en data_processing.py
# Ubicacion: Despues del metodo _normalize_name
# ================================================================

    def normalize_by_rut_decreto(self, registros: List[Dict], log_callback=None) -> List[Dict]:
        """Normaliza monto/horas por RUT + Decreto en el batch actual"""
        if not registros:
            return registros
        
        # Construir mapa RUT + Decreto -> Monto/Horas
        rut_decreto_map = {}
        for r in registros:
            rut = r.get('rut', '').strip()
            decreto = r.get('decreto_alcaldicio', '').strip()
            monto = r.get('monto', '').strip()
            horas = r.get('horas', '').strip()
            
            if rut and decreto and (monto or horas):
                key = f"{rut}_{decreto}"
                if key not in rut_decreto_map:
                    rut_decreto_map[key] = {'monto': monto, 'horas': horas, 'count': 1}
                else:
                    rut_decreto_map[key]['count'] += 1
        
        # Aplicar normalizacion
        aplicados = 0
        for r in registros:
            rut = r.get('rut', '').strip()
            decreto = r.get('decreto_alcaldicio', '').strip()
            
            if rut and decreto:
                key = f"{rut}_{decreto}"
                if key in rut_decreto_map:
                    pattern = rut_decreto_map[key]
                    
                    if pattern.get('monto') and not r.get('monto'):
                        r['monto'] = pattern['monto']
                        r['monto_confidence'] = 0.90
                        r['monto_origen'] = 'batch_rut_decreto'
                        aplicados += 1
                    
                    if pattern.get('horas') and not r.get('horas'):
                        r['horas'] = pattern['horas']
                        r['horas_origen'] = 'batch_rut_decreto'
        
        if log_callback and aplicados > 0:
            log_callback(f"   [OK] {aplicados} campos normalizados por RUT+Decreto", "success")
        
        return registros


# ================================================================
# SNIPPET 2: Modificar IntelligentBatchProcessor.post_process_batch
# Ubicacion: Despues de _normalize_decreto_convenio
# ================================================================

        # Paso 1.5: Normalizar por RUT + Decreto
        registros = self.batch_memory.normalize_by_rut_decreto(registros, log_callback)

        # Paso 1.6: Aplicar patrones conocidos de memoria
        registros = self._apply_known_patterns(registros, log_callback)


# ================================================================
# SNIPPET 3: Agregar metodo a IntelligentBatchProcessor
# Ubicacion: Despues de _needs_review_post_process
# ================================================================

    def _apply_known_patterns(self, registros: List[Dict], log_callback=None) -> List[Dict]:
        """Aplica patrones conocidos RUT + Decreto desde memoria persistente"""
        aplicados = 0
        
        for r in registros:
            rut = r.get('rut', '').strip()
            decreto = r.get('decreto_alcaldicio', '').strip()
            
            if rut and decreto:
                known_payment = self.memory.get_payment_by_rut_decreto(rut, decreto)
                
                if known_payment:
                    if known_payment.get("monto") and not r.get('monto'):
                        r['monto'] = known_payment["monto"]
                        r['monto_confidence'] = 0.95
                        r['monto_origen'] = 'memoria_rut_decreto'
                        aplicados += 1
                    
                    if known_payment.get("horas") and not r.get('horas'):
                        r['horas'] = known_payment["horas"]
                        r['horas_origen'] = 'memoria_rut_decreto'
        
        if log_callback and aplicados > 0:
            log_callback(f"   [OK] {aplicados} pagos aplicados desde memoria RUT+Decreto", "success")
        
        return registros


# ================================================================
# SNIPPET 4: Modificar main.py - _manual_review_process_incremental
# Ubicacion: Dentro de "if dialog.result:", despues de reviewed.append
# ================================================================

            # NUEVO v4.1: Aprender patron RUT + Decreto
            rut = dialog.result.get('rut', '').strip()
            decreto = dialog.result.get('decreto_alcaldicio', '').strip()
            monto = dialog.result.get('monto', '').strip()
            horas = dialog.result.get('horas', '').strip()
            
            if rut and decreto:
                # Guardar en memoria persistente
                self.data_processor.memory.learn_payment_pattern(rut, decreto, monto, horas)
                
                # PROPAGAR a TODOS los pendientes con mismo RUT + Decreto
                actualizados = 0
                for pending in pendientes:
                    if (pending.get('rut') == rut and 
                        pending.get('decreto_alcaldicio') == decreto):
                        
                        if monto and pending.get('monto') 
                            pending['monto'] = monto
                            pending['monto_confidence'] = 0.95
                            pending['monto_origen'] = 'revision_manual_propagada'
                            actualizados += 1
                        
                        if horas and pending.get('horas') 
                            pending['horas'] = horas
                            pending['horas_origen'] = 'revision_manual_propagada'
                            actualizados += 1
                
                if actualizados > 0:
                    boletas_afectadas = len([p for p in pendientes if p.get('rut')==rut and p.get('decreto_alcaldicio')==decreto])
                    self.log(f"   [INFO] Patron aplicado a {actualizados} campos en {boletas_afectadas} boletas similares", "success")


# ================================================================
# SNIPPET 5: Fix monto_num en report_generator.py
# Ubicacion: En _create_main_dataframe, ANTES del return df
# ================================================================

        # Asegurar que monto_num existe SIEMPRE (fix error reportes individuales)
        if 'monto_num' not in df.columns or df['monto_num'].isna().all():
            df["monto_num"] = pd.to_numeric(df.get("monto", ""), errors="coerce").fillna(0)
        
        return df
